"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.eventsToken = exports.beansToken = undefined;
exports.Bean = Bean;
exports.Configuration = Configuration;
exports.bean = bean;
exports.EventListener = EventListener;
exports.Throwable = Throwable;
exports.ThrowableAsync = ThrowableAsync;

var _abstractBeanFactory = require("../org.springframework.beans/abstractBeanFactory");

var _applicationContextEvent = require("./applicationContextEvent");

var __read = undefined && undefined.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = undefined && undefined.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
var beansToken = exports.beansToken = Symbol();
var eventsToken = exports.eventsToken = Symbol();
//
// @Bean
//
function Bean(token, params) {
    params = params || {};
    params.scope = params.scope == null ? "singleton" : params.scope;
    // checks params
    if (!token || params.scope !== "singleton" && params.scope !== "global" && params.scope !== "prototype") {
        throw new Error("[@Bean]: incorrect bean definition params");
    }
    return function (constructor) {
        var beanDefinition = {
            token: token,
            factory: constructor,
            scope: params.scope,
            resolver: params.resolver,
            configuration: false
        };
        // register additional bean
        var beanDefinitions = Reflect.getMetadata(beansToken, _abstractBeanFactory.AbstractBeanFactory) || [];
        Reflect.defineMetadata(beansToken, __spread(beanDefinitions, [beanDefinition]), _abstractBeanFactory.AbstractBeanFactory);
    };
}
//
// @Configuration
//
function Configuration(token, params) {
    params = params || {};
    params.scope = params.scope == null ? "singleton" : params.scope;
    // checks params
    if (!token || params.scope !== "singleton" && params.scope !== "global" && params.scope !== "prototype") {
        throw new Error("[@Configuration]: incorrect bean definition params");
    }
    return function (constructor) {
        var beanDefinition = {
            token: token,
            factory: constructor,
            scope: params.scope,
            resolver: params.resolver,
            configuration: true
        };
        // register additional bean
        var beanDefinitions = Reflect.getMetadata(beansToken, _abstractBeanFactory.AbstractBeanFactory) || [];
        Reflect.defineMetadata(beansToken, __spread(beanDefinitions, [beanDefinition]), _abstractBeanFactory.AbstractBeanFactory);
    };
}
//
// @bean
//
function bean(token, params) {
    params = params || {};
    params.scope = params.scope == null ? "singleton" : params.scope;
    // checks params
    if (!token || params.scope !== "singleton" && params.scope !== "global" && params.scope !== "prototype") {
        throw new Error("[@bean]: incorrect bean definition params");
    }
    return function (target, propertyKey, descriptor) {
        var destination = target.constructor;
        var beanDefinition = {
            token: token,
            factory: null,
            factoryProperty: propertyKey,
            scope: params.scope,
            resolver: params.resolver
        };
        // register additional bean
        var beanDefinitions = Reflect.getMetadata(beansToken, destination) || [];
        Reflect.defineMetadata(beansToken, __spread(beanDefinitions, [beanDefinition]), destination);
    };
}
//
// @EventListener
//
function EventListener(eventClass) {
    return function (target, key, descriptor) {
        var destination = target.constructor;
        var eventListeners = Reflect.getMetadata(eventsToken, destination) || [];
        Reflect.defineMetadata(eventsToken, __spread(eventListeners, [{ key: key, eventClass: eventClass }]), destination);
    };
}
//
// @Throwable
//
function Throwable(context) {
    if (context === void 0) {
        context = null;
    }
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            context = context || this.context;
            var result;
            try {
                result = originalMethod.apply(this, arguments);
            } catch (error) {
                context.publishEvent(new _applicationContextEvent.ApplicationContextBeanRuntimeExceptionEvent(context, error));
                throw error;
            }
            return result;
        };
        return descriptor;
    };
}
//
// @ThrowableAsync
//
function ThrowableAsync(context) {
    if (context === void 0) {
        context = null;
    }
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            context = context || this.context;
            var result = originalMethod.apply(this, arguments);
            result.catch(function (error) {
                context.publishEvent(new _applicationContextEvent.ApplicationContextBeanRuntimeExceptionEvent(context, error));
            });
            return result;
        };
        return descriptor;
    };
}
//# sourceMappingURL=annotations.js.map