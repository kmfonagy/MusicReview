"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceHolder = exports.resourceDependenciesToken = exports.transactionalToken = exports.preDestroyHooksToken = exports.postConstructHooksToken = undefined;
exports.PostConstruct = PostConstruct;
exports.PreDestroy = PreDestroy;
exports.Transactional = Transactional;
exports.Resource = Resource;

var _exception = require("../java/exception");

var __read = undefined && undefined.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = undefined && undefined.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};
var postConstructHooksToken = exports.postConstructHooksToken = Symbol();
var preDestroyHooksToken = exports.preDestroyHooksToken = Symbol();
var transactionalToken = exports.transactionalToken = Symbol();
var resourceDependenciesToken = exports.resourceDependenciesToken = Symbol();
var ResourceHolder = /** @class */function () {
    function ResourceHolder() {}
    return ResourceHolder;
}();
exports.ResourceHolder = ResourceHolder;
//
// @PostConstruct
//

function PostConstruct(target, key, descriptor) {
    var destination = target.constructor;
    if (!Reflect.hasMetadata(postConstructHooksToken, destination)) {
        Reflect.defineMetadata(postConstructHooksToken, key, destination);
    } else {
        throw new Error("[@PostConstruct]: method already exists");
    }
}
//
// @PreDestroy
//
function PreDestroy(target, key, descriptor) {
    var destination = target.constructor;
    if (!Reflect.hasMetadata(preDestroyHooksToken, destination)) {
        Reflect.defineMetadata(preDestroyHooksToken, key, destination);
    } else {
        throw new Error("[@PreDestroy]: method already exists");
    }
}
//
// @Transactional
//
function Transactional(params) {
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var transactionManager = this.transactionManager;
            var result = null;
            try {
                transactionManager.begin(params);
                result = originalMethod.apply(this, arguments);
                if (result instanceof Promise) {
                    var promise = result;
                    promise.then(function (result) {
                        transactionManager.commit();
                        return result;
                    }).catch(function (e) {
                        transactionManager.rollback();
                        throw e;
                    });
                } else {
                    transactionManager.commit();
                }
            } catch (e) {
                transactionManager.rollback();
                throw e;
            }
            return result;
        };
        return descriptor;
    };
}
//
// @Resource
//
function Resource(url, params) {
    params = params || {};
    params.required = params.required == null ? false : params.required;
    if (url == null) {
        throw new _exception.Exception("[@Resource]: url should not be null");
    }
    return function (target, propertyKey) {
        var destination = target.constructor;
        var dependencies = Reflect.getMetadata(resourceDependenciesToken, destination) || [];
        var resources = Reflect.getMetadata(resourceDependenciesToken, ResourceHolder) || [];
        Reflect.defineMetadata(resourceDependenciesToken, __spread(dependencies, [{
            url: url,
            property: propertyKey,
            required: params.required
        }]), destination);
        Reflect.defineMetadata(resourceDependenciesToken, __spread(resources, [{
            url: url
        }]), ResourceHolder);
    };
}
//# sourceMappingURL=annotations.js.map