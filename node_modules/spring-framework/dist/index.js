import 'reflect-metadata';

/**
 * Basic class for exceptions.
 * @remark https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html
 */
var Exception = /** @class */ (function () {
    function Exception(message) {
        this.message = message;
    }
    Exception.prototype.toString = function () {
        return this.message;
    };
    return Exception;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Status of the transaction.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/transaction/TransactionStatus.html
 */
var ETransactionStatus;
(function (ETransactionStatus) {
    ETransactionStatus[ETransactionStatus["closed"] = 0] = "closed";
    ETransactionStatus[ETransactionStatus["opened"] = 1] = "opened";
    ETransactionStatus[ETransactionStatus["suspended"] = 2] = "suspended";
    ETransactionStatus[ETransactionStatus["commited"] = 3] = "commited";
    ETransactionStatus[ETransactionStatus["rollbacked"] = 4] = "rollbacked";
})(ETransactionStatus || (ETransactionStatus = {}));
/**
 * Superclass for all transaction exceptions.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/transaction/TransactionException.html
 */
var TransactionException = /** @class */ (function (_super) {
    __extends(TransactionException, _super);
    function TransactionException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TransactionException;
}(Exception));
/**
 * Thrown when transaction needed.
 * @remark https://docs.oracle.com/javaee/6/api/javax/persistence/TransactionRequiredException.html
 */
var TransactionRequiredException = /** @class */ (function (_super) {
    __extends(TransactionRequiredException, _super);
    function TransactionRequiredException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TransactionRequiredException;
}(Exception));

var postConstructHooksToken = Symbol();
var preDestroyHooksToken = Symbol();
var transactionalToken = Symbol();
var resourceDefinitionToken = Symbol();
var resourceDependenciesToken = Symbol();
//
// @PostConstruct
//
/**
 * Bean lifecycle hook.
 * @remark https://docs.oracle.com/javaee/7/api/javax/annotation/PostConstruct.html
 */
function PostConstruct(target, key, descriptor) {
    var destination = target.constructor;
    if (!Reflect.hasMetadata(postConstructHooksToken, destination)) {
        Reflect.defineMetadata(postConstructHooksToken, key, destination);
    }
    else {
        throw new Error("[@PostConstruct]: method already exists");
    }
}
//
// @PreDestroy
//
/**
 * Bean lifecycle hook.
 * @remark https://docs.oracle.com/javaee/7/api/javax/annotation/PreDestroy.html
 */
function PreDestroy(target, key, descriptor) {
    var destination = target.constructor;
    if (!Reflect.hasMetadata(preDestroyHooksToken, destination)) {
        Reflect.defineMetadata(preDestroyHooksToken, key, destination);
    }
    else {
        throw new Error("[@PreDestroy]: method already exists");
    }
}
//
// @Transactional
//
/**
 * Declarative transaction.
 * Opens transaction for first deep level and keep it to deeps calls for transactional-annotated methods.
 * @remark https://docs.oracle.com/javaee/7/api/javax/transaction/Transactional.html
 * @param params - transaction params
 */
function Transactional(params) {
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                var self, transactionManager, transactionParams, e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            self = this;
                            transactionManager = this
                                .transactionManager;
                            transactionParams = {
                                target: this,
                                operation: originalMethod.apply(self, args)
                            };
                            if (params) {
                                Object.assign(transactionParams, params);
                            }
                            return [4 /*yield*/, transactionManager.begin(transactionParams)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 6]);
                            return [4 /*yield*/, transactionManager.commit()];
                        case 3:
                            _a.sent();
                            return [3 /*break*/, 6];
                        case 4:
                            e_1 = _a.sent();
                            return [4 /*yield*/, transactionManager.rollback()];
                        case 5:
                            _a.sent();
                            if (transactionManager.getTransaction().getStatus() !==
                                ETransactionStatus.rollbacked) {
                                throw e_1;
                            }
                            return [3 /*break*/, 6];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        return descriptor;
    };
}
//
// @Resource
//
/**
 * Autowiring json resource from browser url.
 * At bean instantiation time.
 * @remark https://docs.oracle.com/javase/8/docs/api/javax/annotation/Resource.html
 * @param url - browser url to resource file
 * @param params - resource params
 */
function Resource(url, params) {
    params = params || {};
    params.required = params.required == null ? false : params.required;
    if (url == null) {
        throw new Exception("[@Resource]: url should not be null");
    }
    return function (target, propertyKey) {
        var destination = target.constructor;
        var dependencies = Reflect.getMetadata(resourceDependenciesToken, destination) || [];
        var resources = Reflect.getMetadata(resourceDefinitionToken, destination) || [];
        Reflect.defineMetadata(resourceDependenciesToken, __spread(dependencies, [
            {
                url: url,
                property: propertyKey,
                required: params.required
            }
        ]), destination);
        Reflect.defineMetadata(resourceDefinitionToken, __spread(resources, [
            {
                url: url
            }
        ]), destination);
    };
}

//
var disposableToken = Symbol();
//
// @Disposable
//
/**
 * Represents a disposable resource.
 * @remark http://reactivex.io/RxJava/javadoc/io/reactivex/disposables/Disposable.html
 */
function Disposable(target, propertyKey) {
    var destination = target.constructor;
    if (!Reflect.hasMetadata(disposableToken, destination)) {
        Reflect.defineMetadata(disposableToken, [propertyKey], destination);
    }
    else {
        var keys = Reflect.getMetadata(disposableToken, destination);
        Reflect.defineMetadata(disposableToken, __spread(keys, [propertyKey]), destination);
    }
}

var dependenciesToken = Symbol();
//
// @Autowired
//
/**
 * Inject field (instantiating if needed dependencies).
 * Allowing scopes (prototype, singleton, global).
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html
 * @param wishedBean - bean name or token.
 * @param params - params (required, scope, etc).
 */
function Autowired(wishedBean, params) {
    params = params || {};
    params.required = params.required == null ? false : params.required;
    if (wishedBean == null) {
        throw new Exception("[@Autowired]: wished bean should not be null");
    }
    return function (target, propertyKey) {
        var destination = target.constructor;
        var dependencies = Reflect.getMetadata(dependenciesToken, destination) || [];
        Reflect.defineMetadata(dependenciesToken, __spread(dependencies, [
            {
                property: propertyKey,
                wishedBean: wishedBean,
                required: params.required,
                resolve: params.resolve
            }
        ]), destination);
    };
}

/**
 * Base class for all events.
 */
var ApplicationEvent = /** @class */ (function () {
    function ApplicationEvent() {
    }
    return ApplicationEvent;
}());

/**
 * Base class for events raised for an ApplicationContext.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/event/ApplicationContextEvent.html
 */
var ApplicationContextEvent = /** @class */ (function (_super) {
    __extends(ApplicationContextEvent, _super);
    function ApplicationContextEvent(source) {
        var _this = _super.call(this) || this;
        _this.source = source;
        return _this;
    }
    return ApplicationContextEvent;
}(ApplicationEvent));
/**
 * Event fired when context started and ready to work.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/event/ContextStartedEvent.html
 */
var ApplicationContextStartEvent = /** @class */ (function (_super) {
    __extends(ApplicationContextStartEvent, _super);
    function ApplicationContextStartEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ApplicationContextStartEvent;
}(ApplicationContextEvent));
/**
 * Event fired when context stopped and all beans destroyed.
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/package-summary.html
 */
var ApplicationContextStopEvent = /** @class */ (function (_super) {
    __extends(ApplicationContextStopEvent, _super);
    function ApplicationContextStopEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ApplicationContextStopEvent;
}(ApplicationContextEvent));
/**
 * Event fired when exception catched in throwable-annotated function of bean.
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/BeansException.html
 */
var ApplicationContextBeanRuntimeExceptionEvent = /** @class */ (function (_super) {
    __extends(ApplicationContextBeanRuntimeExceptionEvent, _super);
    function ApplicationContextBeanRuntimeExceptionEvent(source, exception) {
        var _this = _super.call(this, source) || this;
        _this.exception = exception;
        return _this;
    }
    return ApplicationContextBeanRuntimeExceptionEvent;
}(ApplicationContextEvent));

var beansToken = Symbol();
var eventsToken = Symbol();
//
// @Bean
//
/**
 * Mark class be managed by context.
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html
 * @param token - bean token to comply bean instance.
 * @param params - bean params (scope).
 */
function Bean(token, params) {
    params = params || {};
    params.scope = params.scope == null ? "singleton" : params.scope;
    // checks params
    if (!token ||
        (params.scope !== "singleton" &&
            params.scope !== "global" &&
            params.scope !== "prototype")) {
        throw new Error("[@Bean]: incorrect bean definition params");
    }
    return function (constructor) {
        var beanDefinition = {
            token: token,
            factory: constructor,
            scope: params.scope,
            resolver: params.resolver,
            configuration: false
        };
        // register additional bean
        var beanDefinitions = Reflect.getMetadata(beansToken, AbstractBeanFactory) || [];
        Reflect.defineMetadata(beansToken, __spread(beanDefinitions, [beanDefinition]), AbstractBeanFactory);
    };
}
//
// @Configuration
//
/**
 * Mark class as configuration bean.
 * Allows to use bean annotation for methods.
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html
 * @param token
 * @param params
 */
function Configuration(token, params) {
    params = params || {};
    params.scope = params.scope == null ? "singleton" : params.scope;
    // checks params
    if (!token ||
        (params.scope !== "singleton" &&
            params.scope !== "global" &&
            params.scope !== "prototype")) {
        throw new Error("[@Configuration]: incorrect bean definition params");
    }
    return function (constructor) {
        var beanDefinition = {
            token: token,
            factory: constructor,
            scope: params.scope,
            resolver: params.resolver,
            configuration: true
        };
        // register additional bean
        var beanDefinitions = Reflect.getMetadata(beansToken, AbstractBeanFactory) || [];
        Reflect.defineMetadata(beansToken, __spread(beanDefinitions, [beanDefinition]), AbstractBeanFactory);
    };
}
//
// @bean
//
/**
 * Mark method as factory to provide bean.
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html
 * @param token - token to comply bean instance.
 * @param params - bean params (scope).
 */
function bean(token, params) {
    params = params || {};
    params.scope = params.scope == null ? "singleton" : params.scope;
    // checks params
    if (!token ||
        (params.scope !== "singleton" &&
            params.scope !== "global" &&
            params.scope !== "prototype")) {
        throw new Error("[@bean]: incorrect bean definition params");
    }
    return function (target, propertyKey, descriptor) {
        var destination = target.constructor;
        var beanDefinition = {
            token: token,
            factory: null,
            factoryProperty: propertyKey,
            scope: params.scope,
            resolver: params.resolver
        };
        // register additional bean
        var beanDefinitions = Reflect.getMetadata(beansToken, destination) || [];
        Reflect.defineMetadata(beansToken, __spread(beanDefinitions, [beanDefinition]), destination);
    };
}
//
// @EventListener
//
/**
 * Subscribe for events in context.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/event/EventListener.html
 * @param eventClass - event type to subscribe
 */
function EventListener(eventClass) {
    return function (target, key, descriptor) {
        var destination = target.constructor;
        var eventListeners = Reflect.getMetadata(eventsToken, destination) || [];
        Reflect.defineMetadata(eventsToken, __spread(eventListeners, [{ key: key, eventClass: eventClass }]), destination);
    };
}
//
// @Throwable
//
/**
 * All errors in method will be broadcasted to context as ApplicationContextBeanRuntimeExceptionEvent.
 * For sync function.
 * @param context - context to broadcast exceptions
 */
function Throwable(context) {
    if (context === void 0) { context = null; }
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            context = context || this.context;
            var result;
            try {
                result = originalMethod.apply(this, arguments);
            }
            catch (error) {
                context.publishEvent(new ApplicationContextBeanRuntimeExceptionEvent(context, error));
                throw error;
            }
            return result;
        };
        return descriptor;
    };
}
//
// @ThrowableAsync
//
/**
 * All errors in method will be broadcasted to context as ApplicationContextBeanRuntimeExceptionEvent.
 * For async function.
 * @param context - context to broadcast exceptions
 */
function ThrowableAsync(context) {
    if (context === void 0) { context = null; }
    return function (target, key, descriptor) {
        var originalMethod = descriptor.value;
        descriptor.value = function () {
            context = context || this.context;
            var result = originalMethod.apply(this, arguments);
            result.catch(function (error) {
                context.publishEvent(new ApplicationContextBeanRuntimeExceptionEvent(context, error));
            });
            return result;
        };
        return descriptor;
    };
}

//
// Factory for providing beans
//
/**
 * Calculted value wrapped as bean.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html
 */
var FactoryBean = /** @class */ (function () {
    function FactoryBean(factory) {
        this.factory = factory;
    }
    FactoryBean.of = function (factory) {
        return new FactoryBean(factory);
    };
    return FactoryBean;
}());

//
// Types
//
var emptyMap = new Map();
//
// BeanFactory is a Ioc container
//
var PFX = "[ABSTRACT BEAN FACTORY]:";
/**
 * Abstract base class for IBeanFactory implementations.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/support/AbstractBeanFactory.html
 */
var AbstractBeanFactory = /** @class */ (function () {
    /* constructor */
    function AbstractBeanFactory() {
        this.running = false;
        this.beansMap = new Map();
        this.beanPathMap = new Map();
    }
    /**
     * Retrieve instantiated bean from cache.
     */
    AbstractBeanFactory.prototype.findSingletonInstance = function (key) {
        if (this.beansMap.has(key)) {
            return this.beansMap.get(key);
        }
        if (this.parentBeanFactory) {
            return this.parentBeanFactory.findSingletonInstance(key);
        }
        return null;
    };
    /**
     * Retrieve instantiated bean from cache.
     */
    AbstractBeanFactory.prototype.findGlobalInstance = function (key) {
        if (AbstractBeanFactory.beansMap.has(key)) {
            return AbstractBeanFactory.beansMap.get(key);
        }
        return null;
    };
    /**
     * Set bean token mapping.
     * @param key - bean token.
     * @param value - target to which bean token will be mapped (bean name or token).
     */
    AbstractBeanFactory.prototype.set = function (key, value) {
        this.beanPathMap.set(key, value);
    };
    /**
     * Unset bean token mapping.
     * @param key - bean token to unset.
     */
    AbstractBeanFactory.prototype.unset = function (key) {
        this.beanPathMap.delete(key);
    };
    /**
     * Set bean token mapping in batch way.
     * @param beanPathMap - map with beans mapping.
     */
    AbstractBeanFactory.prototype.configure = function (beanPathMap) {
        var e_1, _a;
        try {
            for (var _b = __values(beanPathMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                this.beanPathMap.set(key, beanPathMap.get(key));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Proxy beans to specified context.
     * @param context - context to inherit.
     * @param wishedBeans - beans to proxy to inherited context.
     */
    AbstractBeanFactory.prototype.inherit = function (context, wishedBeans) {
        var _this = this;
        var e_2, _a;
        var _loop_1 = function (whishedBean) {
            this_1.beanPathMap.set(whishedBean, FactoryBean.of(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, context.getBean(whishedBean)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            }); }); }));
        };
        var this_1 = this;
        try {
            for (var wishedBeans_1 = __values(wishedBeans), wishedBeans_1_1 = wishedBeans_1.next(); !wishedBeans_1_1.done; wishedBeans_1_1 = wishedBeans_1.next()) {
                var whishedBean = wishedBeans_1_1.value;
                _loop_1(whishedBean);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (wishedBeans_1_1 && !wishedBeans_1_1.done && (_a = wishedBeans_1.return)) _a.call(wishedBeans_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * Proxy all not found beans to specified context.
     * @param context - context to search not found beans.
     */
    AbstractBeanFactory.prototype.setParent = function (context) {
        this.parentBeanFactory = context;
    };
    /**
     * Execute all disposers in bean.
     * @param instance - bean.
     */
    AbstractBeanFactory.prototype.disposeBean = function (instance) {
        var e_3, _a;
        var key;
        var value;
        try {
            for (var _b = __values(this.beansMap.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                if (entry[1] === instance) {
                    key = entry[0];
                    value = entry[1];
                    break;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!key) {
            throw new Exception(PFX + " no such bean instance");
        }
        var bean = value;
        if (Reflect.hasMetadata(disposableToken, bean.constructor)) {
            var disposerKeys = Reflect.getMetadata(disposableToken, bean.constructor);
            disposerKeys.forEach(function (disposerKey) {
                if (bean[disposerKey] && bean[disposerKey] instanceof Function) {
                    bean[disposerKey].call(bean);
                    bean[disposerKey] = null;
                }
            });
        }
    };
    /**
     * Destroy specified bean without deleting from path map.
     * @param instance - bean.
     */
    AbstractBeanFactory.prototype.destroyBean = function (instance) {
        var e_4, _a;
        var key;
        var value;
        try {
            for (var _b = __values(this.beansMap.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                if (entry[1] === instance) {
                    key = entry[0];
                    value = entry[1];
                    break;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        if (!key) {
            throw new Exception(PFX + " no such bean instance");
        }
        var bean = value;
        this.disposeBean(bean);
        if (Reflect.hasMetadata(preDestroyHooksToken, bean.constructor)) {
            var preDestroyHook = Reflect.getMetadata(preDestroyHooksToken, bean.constructor);
            bean[preDestroyHook].call(bean);
        }
        this.beansMap.delete(key);
    };
    /**
     * Retrieve bean from cache. Similar to getBean but in sync way.
     * @param wishedBean - bean name or token.
     * @param required - if not found and not required function returns null.
     * @param extraBeanPathMap - extension of context bean mapping.
     * @param debug - show bean resolution to console.
     */
    AbstractBeanFactory.prototype.getCachedBean = function (wishedBean, required, extraBeanPathMap, debug) {
        if (required === void 0) { required = true; }
        if (extraBeanPathMap === void 0) { extraBeanPathMap = null; }
        if (debug === void 0) { debug = false; }
        extraBeanPathMap = extraBeanPathMap || emptyMap;
        if (wishedBean == null) {
            throw new Exception(PFX + " wished bean should not be null");
        }
        // 1. resolve string path
        if (typeof wishedBean === "string") {
            // 1.1. resolve string path to either another string path or symbol token
            var nextWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
            // 1.2. try again until get symbol token
            return this.getCachedBean(nextWishedBean, required, extraBeanPathMap, debug);
        }
        // 2. get bean by symbol token
        if (typeof wishedBean === "symbol") {
            // 2.1 search in instances
            if (this.beansMap.has(wishedBean)) {
                return this.beansMap.get(wishedBean);
            }
            // 2.2. resolve symbol token to another token
            if (!this.beanPathMap.has(wishedBean) &&
                !extraBeanPathMap.has(wishedBean)) {
                if (this.parentBeanFactory) {
                    // 2.2.1. resolve in parents
                    var newWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
                    if (!newWishedBean) {
                        // 2.2.1.1. instantiate by token because parents not awared about this token
                        return this.getCachedBeanByToken(wishedBean, required);
                    }
                    else {
                        // 2.2.1.2. try get again with new path that was resolved in parents
                        return this.getCachedBean(newWishedBean, required, extraBeanPathMap, debug);
                    }
                }
                else {
                    // 2.2.2. instantiate by token because there is no parents
                    return this.getCachedBeanByToken(wishedBean, required);
                }
            }
            // 2.3. resolve in itself
            var nextWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
            // 2.4. try get again with new path that was resolved by itself
            return this.getCachedBean(nextWishedBean, required, extraBeanPathMap, debug);
        }
        // 3. get bean by factory
        if (wishedBean instanceof FactoryBean) {
            var beanFactory = wishedBean;
            return beanFactory.factory();
        }
        // 4. bean is resolved from instances
        return wishedBean;
    };
    AbstractBeanFactory.prototype.getCachedBeanByToken = function (token, required) {
        // 1. check beans definitions exists in package
        if (!Reflect.hasMetadata(beansToken, AbstractBeanFactory)) {
            throw new Exception(PFX + " no beans found in context");
        }
        // 2. find bean definition by type
        var beanDefinitions = Reflect.getMetadata(beansToken, AbstractBeanFactory);
        var beanDefinition = beanDefinitions.find(function (beanDefinition) { return beanDefinition.token === token; });
        if (!beanDefinition) {
            if (required) {
                console.log(PFX + " bean with such token not provided in context", token);
                throw new Exception(PFX + " bean with such token not provided in context");
            }
            return null;
        }
        if (beanDefinition.factory == null && beanDefinition.bean == null) {
            throw new Exception(PFX + " incorrect bean definition");
        }
        // 3. get instance
        var bean;
        if (beanDefinition.scope === "singleton") {
            bean = this.findSingletonInstance(beanDefinition.token);
            if (!bean) {
                if (!required) {
                    return null;
                }
                else {
                    throw new Exception(PFX + " retrieving from cache bean not instantiated yet");
                }
            }
        }
        else if (beanDefinition.scope === "global") {
            bean = this.findGlobalInstance(beanDefinition.token);
            if (!bean) {
                if (!required) {
                    return null;
                }
                else {
                    throw new Exception(PFX + " retrieving from cache bean not instantiated yet");
                }
            }
        }
        else if (beanDefinition.scope === "prototype") {
            // instantiate
            throw new Exception(PFX + " retrieving bean should not have prototype scope");
        }
        else {
            throw new Exception(PFX + " usupported scope - " + beanDefinition.scope);
        }
        return bean;
    };
    /**
     * Retrieve bean from cache.
     * @param wishedBean - bean name or token.
     * @param required - if not found and not required function returns null.
     * @param extraBeanPathMap - extension of context bean mapping.
     * @param debug - show bean resolution to console.
     */
    AbstractBeanFactory.prototype.getBean = function (wishedBean, required, extraBeanPathMap, debug) {
        if (required === void 0) { required = true; }
        if (extraBeanPathMap === void 0) { extraBeanPathMap = null; }
        if (debug === void 0) { debug = false; }
        return __awaiter(this, void 0, void 0, function () {
            var nextWishedBean, newWishedBean, nextWishedBean, beanFactory;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        extraBeanPathMap = extraBeanPathMap || emptyMap;
                        if (debug) {
                            console.log(PFX + " getBean", wishedBean);
                        }
                        if (wishedBean == null) {
                            throw new Exception(PFX + " wished bean should not be null");
                        }
                        if (!(typeof wishedBean === "string")) return [3 /*break*/, 2];
                        nextWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
                        return [4 /*yield*/, this.getBean(nextWishedBean, required, extraBeanPathMap, debug)];
                    case 1: 
                    // 1.2. try again until get symbol token
                    return [2 /*return*/, _a.sent()];
                    case 2:
                        if (!(typeof wishedBean === "symbol")) return [3 /*break*/, 11];
                        // 2.1 search in instances
                        if (this.beansMap.has(wishedBean)) {
                            return [2 /*return*/, this.beansMap.get(wishedBean)];
                        }
                        if (!(!this.beanPathMap.has(wishedBean) &&
                            !extraBeanPathMap.has(wishedBean))) return [3 /*break*/, 9];
                        if (!this.parentBeanFactory) return [3 /*break*/, 7];
                        newWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
                        if (!!newWishedBean) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getBeanByToken(wishedBean, required, extraBeanPathMap, debug)];
                    case 3: 
                    // 2.2.1.1. instantiate by token because parents not awared about this token
                    return [2 /*return*/, _a.sent()];
                    case 4: return [4 /*yield*/, this.getBean(newWishedBean, required, extraBeanPathMap, debug)];
                    case 5: 
                    // 2.2.1.2. try get again with new path that was resolved in parents
                    return [2 /*return*/, _a.sent()];
                    case 6: return [3 /*break*/, 9];
                    case 7: return [4 /*yield*/, this.getBeanByToken(wishedBean, required, extraBeanPathMap, debug)];
                    case 8: 
                    // 2.2.2. instantiate by token because there is no parents
                    return [2 /*return*/, _a.sent()];
                    case 9:
                        nextWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
                        return [4 /*yield*/, this.getBean(nextWishedBean, required, extraBeanPathMap, debug)];
                    case 10: 
                    // 2.4. try get again with new path that was resolved by itself
                    return [2 /*return*/, _a.sent()];
                    case 11:
                        // 3. get bean by factory
                        if (wishedBean instanceof FactoryBean) {
                            beanFactory = wishedBean;
                            return [2 /*return*/, beanFactory.factory()];
                        }
                        // 4. bean is resolved from instances
                        return [2 /*return*/, wishedBean];
                }
            });
        });
    };
    /**
     * Resolve bean name or token.
     * @param wishedBean - bean name or token.
     * @param extraBeanPathMap - extension of context bean mapping.
     */
    AbstractBeanFactory.prototype.resolveBean = function (wishedBean, extraBeanPathMap) {
        if (extraBeanPathMap === void 0) { extraBeanPathMap = null; }
        extraBeanPathMap = extraBeanPathMap || emptyMap;
        // 1. search in instances
        if (this.beansMap.has(wishedBean)) {
            return this.beansMap.get(wishedBean);
        }
        // 2. search bean path mapping in itself
        if (!this.beanPathMap.has(wishedBean) &&
            !extraBeanPathMap.has(wishedBean)) {
            // 2.1. search bean path mapping in parents
            if (this.parentBeanFactory) {
                return this.parentBeanFactory.resolveBean(wishedBean, extraBeanPathMap);
            }
            // 2.2. not resolved
            return null;
        }
        // 3. retrieve path mapping from itself
        if (this.beanPathMap.has(wishedBean)) {
            return this.beanPathMap.get(wishedBean);
        }
        else {
            return extraBeanPathMap.get(wishedBean);
        }
    };
    AbstractBeanFactory.prototype.getBeanByToken = function (token, required, extraBeanPathMap, debug) {
        if (debug === void 0) { debug = false; }
        return __awaiter(this, void 0, void 0, function () {
            var beanDefinitions, beanDefinition, bean, beansDefinitions, postConstructHook, result;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // 1. check beans definitions exists in package
                        if (!Reflect.hasMetadata(beansToken, AbstractBeanFactory)) {
                            throw new Exception(PFX + " no beans found in context");
                        }
                        beanDefinitions = Reflect.getMetadata(beansToken, AbstractBeanFactory);
                        beanDefinition = beanDefinitions.find(function (beanDefinition) { return beanDefinition.token === token; });
                        if (!beanDefinition) {
                            if (required) {
                                console.log(PFX + " bean with such token not provided in context", token);
                                throw new Exception(PFX + " bean with such token not provided in context");
                            }
                            return [2 /*return*/, null];
                        }
                        if (beanDefinition.factory == null && beanDefinition.bean == null) {
                            throw new Exception(PFX + " incorrect bean definition");
                        }
                        if (!(beanDefinition.scope === "singleton")) return [3 /*break*/, 5];
                        bean = this.findSingletonInstance(beanDefinition.token);
                        if (!!bean) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.instantiateBean(beanDefinition)];
                    case 1:
                        // instantiate
                        bean = _a.sent();
                        this.beansMap.set(beanDefinition.token, bean);
                        return [4 /*yield*/, this.autowire(bean, beanDefinition, extraBeanPathMap, debug)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.resource(bean, beanDefinition)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [3 /*break*/, 15];
                    case 5:
                        if (!(beanDefinition.scope === "global")) return [3 /*break*/, 10];
                        bean = this.findGlobalInstance(beanDefinition.token);
                        if (!!bean) return [3 /*break*/, 9];
                        return [4 /*yield*/, this.instantiateBean(beanDefinition)];
                    case 6:
                        // instantiate
                        bean = _a.sent();
                        AbstractBeanFactory.beansMap.set(beanDefinition.token, bean);
                        return [4 /*yield*/, this.autowire(bean, beanDefinition, extraBeanPathMap, debug)];
                    case 7:
                        _a.sent();
                        return [4 /*yield*/, this.resource(bean, beanDefinition)];
                    case 8:
                        _a.sent();
                        _a.label = 9;
                    case 9: return [3 /*break*/, 15];
                    case 10:
                        if (!(beanDefinition.scope === "prototype")) return [3 /*break*/, 14];
                        return [4 /*yield*/, this.instantiateBean(beanDefinition)];
                    case 11:
                        // instantiate
                        bean = _a.sent();
                        this.beansMap.set(Symbol(), bean);
                        return [4 /*yield*/, this.autowire(bean, beanDefinition, extraBeanPathMap, debug)];
                    case 12:
                        _a.sent();
                        return [4 /*yield*/, this.resource(bean, beanDefinition)];
                    case 13:
                        _a.sent();
                        return [3 /*break*/, 15];
                    case 14: throw new Exception(PFX + " usupported scope - " + beanDefinition.scope);
                    case 15:
                        if (!(beanDefinition.factory != null)) return [3 /*break*/, 17];
                        // 4. for configuration bean register all declared @beans
                        if (Reflect.hasMetadata(beansToken, bean.constructor)) {
                            beansDefinitions = Reflect.getMetadata(beansToken, bean.constructor);
                            beansDefinitions.forEach(function (beanDefinition) {
                                // register additional bean
                                var beanDefinitions = Reflect.getMetadata(beansToken, AbstractBeanFactory) || [];
                                Reflect.defineMetadata(beansToken, __spread([
                                    __assign({}, beanDefinition, { bean: bean })
                                ], beanDefinitions), AbstractBeanFactory);
                                _this.unset(beanDefinition.token);
                            });
                        }
                        if (!Reflect.hasMetadata(postConstructHooksToken, bean.constructor)) return [3 /*break*/, 17];
                        postConstructHook = Reflect.getMetadata(postConstructHooksToken, bean.constructor);
                        result = bean[postConstructHook].call(bean);
                        if (!(result instanceof Promise)) return [3 /*break*/, 17];
                        return [4 /*yield*/, result];
                    case 16:
                        _a.sent();
                        _a.label = 17;
                    case 17: return [2 /*return*/, bean];
                }
            });
        });
    };
    AbstractBeanFactory.prototype.instantiateBean = function (beanDefinition) {
        return __awaiter(this, void 0, void 0, function () {
            var type, bean;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (beanDefinition.factory != null) {
                            type = beanDefinition.factory.prototype;
                            return [2 /*return*/, new type.constructor(this)];
                        }
                        if (!beanDefinition.bean) {
                            throw new Exception(PFX + " bean should not be null");
                        }
                        return [4 /*yield*/, beanDefinition.bean[beanDefinition.factoryProperty]];
                    case 1:
                        bean = _a.sent();
                        return [2 /*return*/, bean.call(beanDefinition.bean)];
                }
            });
        });
    };
    AbstractBeanFactory.prototype.autowire = function (bean, beanDefinition, extraBeanPathMap, debug) {
        if (debug === void 0) { debug = false; }
        return __awaiter(this, void 0, void 0, function () {
            var e_5, _a, dependencies, _loop_2, this_2, dependencies_1, dependencies_1_1, dependency, e_5_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!beanDefinition.factory) {
                            return [2 /*return*/];
                        }
                        if (!Reflect.hasMetadata(dependenciesToken, bean.constructor)) return [3 /*break*/, 8];
                        dependencies = Reflect.getMetadata(dependenciesToken, bean.constructor);
                        _loop_2 = function (dependency) {
                            var propertyName, propertyValue, resolverPath, resolverBean, resolvedArray, resolverMap_1, _a, _b;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0:
                                        propertyName = dependency.property;
                                        propertyValue = bean[propertyName];
                                        if (!!propertyValue) return [3 /*break*/, 4];
                                        if (dependency.wishedBean == null) {
                                            throw new Exception(PFX + " incorrect dependency definition for " + dependency.property);
                                        }
                                        if (!dependency.resolve) return [3 /*break*/, 2];
                                        resolverPath = beanDefinition.resolver;
                                        return [4 /*yield*/, this_2.getBean(resolverPath, true, extraBeanPathMap, debug)];
                                    case 1:
                                        resolverBean = _c.sent();
                                        resolvedArray = resolverBean.resolve(dependency.resolve, bean);
                                        if (resolvedArray) {
                                            resolverMap_1 = new Map(resolvedArray);
                                            extraBeanPathMap.forEach(function (v, k) { return resolverMap_1.set(k, v); });
                                            extraBeanPathMap = resolverMap_1;
                                        }
                                        _c.label = 2;
                                    case 2:
                                        _a = bean;
                                        _b = propertyName;
                                        return [4 /*yield*/, this_2.getBean(dependency.wishedBean, dependency.required, extraBeanPathMap, debug)];
                                    case 3:
                                        _a[_b] = _c.sent();
                                        return [3 /*break*/, 5];
                                    case 4: throw new Exception(PFX + " autowired property should be null " + dependency.property);
                                    case 5: return [2 /*return*/];
                                }
                            });
                        };
                        this_2 = this;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        dependencies_1 = __values(dependencies), dependencies_1_1 = dependencies_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!dependencies_1_1.done) return [3 /*break*/, 5];
                        dependency = dependencies_1_1.value;
                        return [5 /*yield**/, _loop_2(dependency)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        dependencies_1_1 = dependencies_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_5_1 = _b.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (dependencies_1_1 && !dependencies_1_1.done && (_a = dependencies_1.return)) _a.call(dependencies_1);
                        }
                        finally { if (e_5) throw e_5.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    AbstractBeanFactory.prototype.resource = function (bean, beanDefinition) {
        return __awaiter(this, void 0, void 0, function () {
            var e_6, _a, resources, resources_1, resources_1_1, resource, propertyName, propertyValue, _b, _c, e_6_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!beanDefinition.factory) {
                            return [2 /*return*/];
                        }
                        if (!Reflect.hasMetadata(resourceDependenciesToken, bean.constructor)) return [3 /*break*/, 9];
                        resources = Reflect.getMetadata(resourceDependenciesToken, bean.constructor);
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 7, 8, 9]);
                        resources_1 = __values(resources), resources_1_1 = resources_1.next();
                        _d.label = 2;
                    case 2:
                        if (!!resources_1_1.done) return [3 /*break*/, 6];
                        resource = resources_1_1.value;
                        propertyName = resource.property;
                        propertyValue = bean[propertyName];
                        if (!!propertyValue) return [3 /*break*/, 4];
                        _b = bean;
                        _c = propertyName;
                        return [4 /*yield*/, this.getResource(resource.url)];
                    case 3:
                        _b[_c] = _d.sent();
                        return [3 /*break*/, 5];
                    case 4: throw new Exception(PFX + " resource property should be null " + resource.property);
                    case 5:
                        resources_1_1 = resources_1.next();
                        return [3 /*break*/, 2];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_6_1 = _d.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (resources_1_1 && !resources_1_1.done && (_a = resources_1.return)) _a.call(resources_1);
                        }
                        finally { if (e_6) throw e_6.error; }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    //
    // ICloseable implementation
    //
    /**
     * Destroy all beans in context and erase beans names mapping.
     */
    AbstractBeanFactory.prototype.close = function () {
        if (this.isRunning()) {
            this.stop();
        }
        this.beanPathMap = null;
        this.beansMap = null;
    };
    //
    // ILifecycle implementation
    //
    /**
     * Start context
     */
    AbstractBeanFactory.prototype.start = function () {
        if (!this.isRunning()) {
            if (this.beanPathMap && this.beansMap) {
                this.running = true;
            }
            else {
                throw new Exception(PFX + " bean factory has not configured");
            }
        }
        else {
            throw new Exception(PFX + " bean factory already started");
        }
    };
    /**
     * Destroy all beans in context but keep bean names mapping.
     */
    AbstractBeanFactory.prototype.stop = function () {
        var e_7, _a, e_8, _b;
        if (this.isRunning()) {
            var disposeBeansKeys = this.beansMap.keys();
            try {
                for (var disposeBeansKeys_1 = __values(disposeBeansKeys), disposeBeansKeys_1_1 = disposeBeansKeys_1.next(); !disposeBeansKeys_1_1.done; disposeBeansKeys_1_1 = disposeBeansKeys_1.next()) {
                    var key = disposeBeansKeys_1_1.value;
                    var bean = this.beansMap.get(key);
                    this.disposeBean(bean);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (disposeBeansKeys_1_1 && !disposeBeansKeys_1_1.done && (_a = disposeBeansKeys_1.return)) _a.call(disposeBeansKeys_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
            var destroyBeansKeys = this.beansMap.keys();
            try {
                for (var destroyBeansKeys_1 = __values(destroyBeansKeys), destroyBeansKeys_1_1 = destroyBeansKeys_1.next(); !destroyBeansKeys_1_1.done; destroyBeansKeys_1_1 = destroyBeansKeys_1.next()) {
                    var key = destroyBeansKeys_1_1.value;
                    var bean = this.beansMap.get(key);
                    this.destroyBean(bean);
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (destroyBeansKeys_1_1 && !destroyBeansKeys_1_1.done && (_b = destroyBeansKeys_1.return)) _b.call(destroyBeansKeys_1);
                }
                finally { if (e_8) throw e_8.error; }
            }
            this.running = false;
        }
        else {
            throw new Exception(PFX + " bean factory has not started");
        }
    };
    /**
     * Wheather context running and beans ready to retrieving.
     */
    AbstractBeanFactory.prototype.isRunning = function () {
        return this.running;
    };
    AbstractBeanFactory.beansMap = new Map();
    return AbstractBeanFactory;
}());

/**
 * Application context holder.
 * Singleton.
 * @remark https://syncope.apache.org/apidocs/2.0/org/apache/syncope/core/spring/ApplicationContextProvider.html
 */
var ApplicationContextProvider = /** @class */ (function () {
    function ApplicationContextProvider() {
    }
    /**
     * Get application context provider singleton object
     */
    ApplicationContextProvider.get = function () {
        if (!ApplicationContextProvider.instance) {
            ApplicationContextProvider.instance = new ApplicationContextProvider();
        }
        return ApplicationContextProvider.instance;
    };
    /**
     * Get application context from holder
     */
    ApplicationContextProvider.prototype.getApplicationContext = function () {
        return this.context;
    };
    /**
     * Set application context to hold on
     * @param context - context to keep
     */
    ApplicationContextProvider.prototype.setApplicationContext = function (context) {
        this.context = context;
    };
    ApplicationContextProvider.instance = null;
    return ApplicationContextProvider;
}());

//
// Context is a Ioc container with event system
//
var PFX$1 = "[ABSTRACT APPLICATION CONTEXT]:";
/**
 * Abstract implementation of the ApplicationContext interface.
 * @remark https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/support/AbstractApplicationContext.html
 */
var AbstractApplicationContext = /** @class */ (function (_super) {
    __extends(AbstractApplicationContext, _super);
    function AbstractApplicationContext() {
        var _this = _super.call(this) || this;
        _this.parentBeanFactory = null;
        return _this;
    }
    /**
     * Broadcast event to all subscribed beans in context.
     * @param event - application event to broadcast.
     */
    AbstractApplicationContext.prototype.publishEvent = function (event) {
        if (this.beansMap) {
            this.beansMap.forEach(function (bean) {
                if (Reflect.hasMetadata(eventsToken, bean.constructor)) {
                    var eventListenerRecords = Reflect.getMetadata(eventsToken, bean.constructor);
                    eventListenerRecords.forEach(function (record) {
                        if (event instanceof record.eventClass) {
                            bean[record.key].call(bean, event);
                        }
                    });
                }
            });
        }
        else {
            throw new Exception(PFX$1 + " could not publish event - context not started");
        }
        // broadcast to parent contexts
        if (this.parentBeanFactory && this.parentBeanFactory.isRunning()) {
            this.parentBeanFactory.publishEvent(event);
        }
    };
    //
    // ILifecycle implementation
    //
    /**
     * Start context.
     */
    AbstractApplicationContext.prototype.start = function () {
        _super.prototype.start.call(this);
        this.publishEvent(new ApplicationContextStartEvent(this));
    };
    /**
     * Destroy all beans in context but keep names mappings.
     */
    AbstractApplicationContext.prototype.stop = function () {
        this.publishEvent(new ApplicationContextStopEvent(this));
        _super.prototype.stop.call(this);
    };
    /**
     * Destroy all beans in context and delete beans mappings.
     */
    AbstractApplicationContext.prototype.close = function () {
        _super.prototype.close.call(this);
    };
    //
    // Overrides
    //
    /**
     * Get resource from server.
     * @param url - json resource url
     */
    AbstractApplicationContext.prototype.getResource = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var response, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(url)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, data];
                }
            });
        });
    };
    return AbstractApplicationContext;
}(AbstractBeanFactory));

var PFX$2 = "[JSON APPLICATION CONTEXT]:";
/**
 * Application context loaded from remote json configuration file (like xml in spring)
 * @remark https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html
 */
var JsonUrlApplicationContext = /** @class */ (function (_super) {
    __extends(JsonUrlApplicationContext, _super);
    function JsonUrlApplicationContext(url) {
        var _this = _super.call(this) || this;
        _this.url = url;
        return _this;
    }
    /**
     * Load context from url.
     */
    JsonUrlApplicationContext.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var response, schema;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(this.url)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2:
                        schema = _a.sent();
                        this.schema = schema;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Load beans configuration from context file.
     * @param debug - show beans definition to console
     */
    JsonUrlApplicationContext.prototype.configureBeansDefinitions = function (debug) {
        var beansDefinition = this.schema.beansDefinition.map(function (beanDefinition) { return [beanDefinition.abstraction, beanDefinition.support]; });
        if (debug) {
            console.log(PFX$2 + " beans definition");
        }
        beansDefinition.forEach(function (beanDefinition) {
            if (debug) {
                console.log(PFX$2 + " + mapped " + beanDefinition[0] + " to " + beanDefinition[1]);
            }
        });
        _super.prototype.configure.call(this, new Map(beansDefinition));
    };
    /**
     * Instantiate beans specified in context file.
     * @param debug - show beans instantiated to console
     */
    JsonUrlApplicationContext.prototype.startSchemaBeans = function (debug) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, beans, beans_1, beans_1_1, bean, e_1_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        beans = this.schema.beans;
                        if (debug) {
                            console.log(PFX$2 + " initial beans");
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        beans_1 = __values(beans), beans_1_1 = beans_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!beans_1_1.done) return [3 /*break*/, 5];
                        bean = beans_1_1.value;
                        if (debug) {
                            console.log(PFX$2 + " + bean=" + bean.id + " required=" + !bean.optional);
                        }
                        return [4 /*yield*/, this.getBean(bean.id, !bean.optional, null, debug)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        beans_1_1 = beans_1.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (beans_1_1 && !beans_1_1.done && (_a = beans_1.return)) _a.call(beans_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    return JsonUrlApplicationContext;
}(AbstractApplicationContext));

//
var testsToken = Symbol();
var asyncTestsToken = Symbol();
var spiesToken = Symbol();
var spiesValuesToken = Symbol();
var spiesOnGetToken = Symbol();
//
// @Test
//
/**
 * Mark bean method as test.
 * @remark https://junit.org/junit4/javadoc/4.12/org/junit/Test.html
 */
function Test(target, key, descriptor) {
    var destination = target.constructor;
    var keys = Reflect.getMetadata(testsToken, destination) || [];
    Reflect.defineMetadata(testsToken, __spread([key], keys), destination);
}
//
// @AsyncTest
//
/**
 * Mark bean method as async test.
 * @remark https://junit.org/junit4/javadoc/4.12/org/junit/Test.html
 */
function AsyncTest(target, key, descriptor) {
    var destination = target.constructor;
    var keys = Reflect.getMetadata(asyncTestsToken, destination) || [];
    Reflect.defineMetadata(asyncTestsToken, __spread([key], keys), destination);
}
//
// @Spy
//
/**
 * Spy for bean method.
 */
function Spy(target, key, descriptor) {
    var destination = target.constructor;
    var keys = Reflect.getMetadata(spiesToken, destination) || [];
    Reflect.defineMetadata(spiesToken, __spread([key], keys), destination);
}
//
// @SpyOnGet
//
/**
 * Spy for bean getter.
 */
function SpyOnGet(target, key, descriptor) {
    var destination = target.constructor;
    var keys = Reflect.getMetadata(spiesOnGetToken, destination) || [];
    Reflect.defineMetadata(spiesOnGetToken, __spread([key], keys), destination);
}

/**
 * Register all test in bean.
 * @param token - bean token.
 * @param type - bean class.
 * @param contextGetter - getter of context from retrieve bean.
 */
function registerAllTest(token, type, contextGetter) {
    var _this = this;
    if (Reflect.hasMetadata(testsToken, type)) {
        var keys = Reflect.getMetadata(testsToken, type);
        var _loop_1 = function (i) {
            var name_1 = keys[i];
            it(name_1, function () { return __awaiter(_this, void 0, void 0, function () {
                var bean, f;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, contextGetter().getBean(token)];
                        case 1:
                            bean = _a.sent();
                            f = bean[name_1];
                            f.call(bean, contextGetter());
                            return [2 /*return*/];
                    }
                });
            }); });
        };
        for (var i = 0; i < keys.length; ++i) {
            _loop_1(i);
        }
    }
    if (Reflect.hasMetadata(asyncTestsToken, type)) {
        var keys = Reflect.getMetadata(asyncTestsToken, type);
        var _loop_2 = function (i) {
            var name_2 = keys[i];
            it(name_2, function () { return __awaiter(_this, void 0, void 0, function () {
                var bean, f;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, contextGetter().getBean(token)];
                        case 1:
                            bean = _a.sent();
                            f = bean[name_2];
                            return [4 /*yield*/, f.call(bean, contextGetter())];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
        };
        for (var i = 0; i < keys.length; ++i) {
            _loop_2(i);
        }
    }
}
/**
 * Init annotated mocks in bean.
 * @param token - bean token.
 * @param type - bean class.
 * @param context - context from retrieve bean.
 */
function initMocks(token, type, context) {
    return __awaiter(this, void 0, void 0, function () {
        var obj, keys, i, name_3, spy, spies, keys, i, name_4, spy, spies;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, context.getBean(token)];
                case 1:
                    obj = _a.sent();
                    if (Reflect.hasMetadata(spiesToken, type)) {
                        keys = Reflect.getMetadata(spiesToken, type);
                        for (i = 0; i < keys.length; ++i) {
                            name_3 = keys[i];
                            spy = jest.spyOn(obj, name_3);
                            if (!Reflect.hasMetadata(spiesValuesToken, obj)) {
                                Reflect.defineMetadata(spiesValuesToken, [spy], obj);
                            }
                            else {
                                spies = Reflect.getMetadata(spiesValuesToken, obj);
                                Reflect.defineMetadata(spiesValuesToken, __spread([spy], spies), obj);
                            }
                        }
                    }
                    if (Reflect.hasMetadata(spiesOnGetToken, type)) {
                        keys = Reflect.getMetadata(spiesOnGetToken, type);
                        for (i = 0; i < keys.length; ++i) {
                            name_4 = keys[i];
                            spy = jest.spyOn(obj, name_4, "get");
                            if (!Reflect.hasMetadata(spiesValuesToken, obj)) {
                                Reflect.defineMetadata(spiesValuesToken, [spy], obj);
                            }
                            else {
                                spies = Reflect.getMetadata(spiesValuesToken, obj);
                                Reflect.defineMetadata(spiesValuesToken, __spread([spy], spies), obj);
                            }
                        }
                    }
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * Deinit mocks in bean.
 * @param token - bean token.
 * @param type - bean class.
 * @param context - context from retrieve bean.
 */
function deinitMocks(token, type, context) {
    return __awaiter(this, void 0, void 0, function () {
        var obj, keys, i, spy;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, context.getBean(token)];
                case 1:
                    obj = _a.sent();
                    if (Reflect.hasMetadata(spiesValuesToken, obj)) {
                        keys = Reflect.getMetadata(spiesValuesToken, obj);
                        for (i = 0; i < keys.length; ++i) {
                            spy = keys[i];
                            spy.mockRestore();
                        }
                    }
                    return [2 /*return*/];
            }
        });
    });
}

/**
 * Abstract transaction.
 * Basic implementation for Transaction interface.
 * @remark https://tinkerpop.apache.org/javadocs/3.3.0/full/org/apache/tinkerpop/gremlin/structure/util/AbstractTransaction.html
 */
var AbstractTransaction = /** @class */ (function () {
    /* constructor */
    function AbstractTransaction() {
        this.commitingOperations = [];
        this.status = ETransactionStatus.opened;
    }
    //
    // Api
    //
    AbstractTransaction.prototype.commit = function (operations) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, operations_1, operations_1_1, operation, e_1_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 7]);
                        operations_1 = __values(operations), operations_1_1 = operations_1.next();
                        _b.label = 1;
                    case 1:
                        if (!!operations_1_1.done) return [3 /*break*/, 4];
                        operation = operations_1_1.value;
                        this.commitingOperations.push(operation);
                        return [4 /*yield*/, operation.commit()];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        operations_1_1 = operations_1.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (operations_1_1 && !operations_1_1.done && (_a = operations_1.return)) _a.call(operations_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 7:
                        this.commitingOperations = [];
                        this.status = ETransactionStatus.commited;
                        return [2 /*return*/];
                }
            });
        });
    };
    AbstractTransaction.prototype.rollback = function (operations) {
        return __awaiter(this, void 0, void 0, function () {
            var e_2, _a, _b, _c, operation, e_2_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 5, 6, 7]);
                        _b = __values(this.commitingOperations), _c = _b.next();
                        _d.label = 1;
                    case 1:
                        if (!!_c.done) return [3 /*break*/, 4];
                        operation = _c.value;
                        return [4 /*yield*/, operation.rollback()];
                    case 2:
                        _d.sent();
                        _d.label = 3;
                    case 3:
                        _c = _b.next();
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 7];
                    case 5:
                        e_2_1 = _d.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 7];
                    case 6:
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 7:
                        this.commitingOperations = [];
                        this.status = ETransactionStatus.rollbacked;
                        return [2 /*return*/];
                }
            });
        });
    };
    AbstractTransaction.prototype.getStatus = function () {
        return this.status;
    };
    return AbstractTransaction;
}());

/**
 * Base class for all transaction managers.
 * Base implmentation of TransactionManager interface.
 * Implements semaphore way to manage keep single transaction via transactional-annotated functions deep calls.
 */
var AbstractTransactionManager = /** @class */ (function () {
    /* constructor */
    function AbstractTransactionManager() {
        this.semaphore = 0;
    }
    /**
     * start transaction
     */
    AbstractTransactionManager.prototype.begin = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.semaphore === 0)) return [3 /*break*/, 2];
                        this.operations = [];
                        _a = this;
                        return [4 /*yield*/, this.transactionFactory()];
                    case 1:
                        _a.transaction = _b.sent();
                        _b.label = 2;
                    case 2:
                        this.semaphore += 1;
                        this.operations.push(params.operation);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * commit transaction
     */
    AbstractTransactionManager.prototype.commit = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.transaction) {
                            throw new TransactionRequiredException();
                        }
                        if (!(this.semaphore === 1)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.transaction.commit(this.operations)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.semaphore -= 1;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * rollback transaction
     */
    AbstractTransactionManager.prototype.rollback = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.transaction) {
                            throw new TransactionRequiredException();
                        }
                        if (!(this.semaphore === 1)) return [3 /*break*/, 4];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.transaction.rollback(this.operations)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        console.error("Uncaughted exception in transaction rollback", this.transaction);
                        return [3 /*break*/, 4];
                    case 4:
                        this.semaphore -= 1;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * suspend transaction
     */
    AbstractTransactionManager.prototype.suspend = function () {
        this.suspended = true;
    };
    /**
     * resume transaction
     */
    AbstractTransactionManager.prototype.resume = function () {
        this.suspended = false;
    };
    /**
     * close transaction
     */
    AbstractTransactionManager.prototype.close = function () {
        delete this.transaction;
        this.operations = [];
        this.semaphore = 0;
    };
    /**
     * get status of transaction
     */
    AbstractTransactionManager.prototype.getStatus = function () {
        return this.transaction
            ? this.transaction.getStatus()
            : ETransactionStatus.closed;
    };
    /**
     * get transaction object
     */
    AbstractTransactionManager.prototype.getTransaction = function () {
        return this.transaction;
    };
    return AbstractTransactionManager;
}());

export { AbstractApplicationContext, AbstractBeanFactory, AbstractTransaction, AbstractTransactionManager, ApplicationContextBeanRuntimeExceptionEvent, ApplicationContextEvent, ApplicationContextProvider, ApplicationContextStartEvent, ApplicationContextStopEvent, ApplicationEvent, AsyncTest, Autowired, Bean, Configuration, Disposable, ETransactionStatus, EventListener, Exception, FactoryBean, JsonUrlApplicationContext, PostConstruct, PreDestroy, Resource, Spy, SpyOnGet, Test, Throwable, ThrowableAsync, TransactionException, TransactionRequiredException, Transactional, asyncTestsToken, bean, beansToken, deinitMocks, dependenciesToken, disposableToken, eventsToken, initMocks, postConstructHooksToken, preDestroyHooksToken, registerAllTest, resourceDefinitionToken, resourceDependenciesToken, spiesOnGetToken, spiesToken, spiesValuesToken, testsToken, transactionalToken };
