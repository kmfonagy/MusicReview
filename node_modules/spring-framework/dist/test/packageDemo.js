"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChildContext = exports.ApplicationConfiguration = exports.Bean3Test = exports.Bean1Test = exports.ApplicationTestContext = exports.ApplicationContext = exports.Bean2 = exports.Bean1 = exports.CustomApplicationEvent = exports.CustomConsolePrefixToken = exports.ConfigurationToken = exports.Bean1TestToken = exports.Bean3Token = exports.Bean2Token = exports.Bean1Token = exports.ConcreteValueToken = exports.AbstractValueToken = exports.ApplicationContextToken = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _2 = require("..");

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function (thisArg, body) {
    var _ = { label: 0, sent: function sent() {
            if (t[0] & 1) throw t[1];return t[1];
        }, trys: [], ops: [] },
        f,
        y,
        t,
        g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
    }), g;
    function verb(n) {
        return function (v) {
            return step([n, v]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) {
            try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0:case 1:
                        t = op;break;
                    case 4:
                        _.label++;return { value: op[1], done: false };
                    case 5:
                        _.label++;y = op[1];op = [0];continue;
                    case 7:
                        op = _.ops.pop();_.trys.pop();continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];t = op;break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];_.ops.push(op);break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [6, e];y = 0;
            } finally {
                f = t = 0;
            }
        }if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
};

//
// Tokens
//
var ApplicationContextToken = exports.ApplicationContextToken = Symbol();
var AbstractValueToken = exports.AbstractValueToken = Symbol();
var ConcreteValueToken = exports.ConcreteValueToken = Symbol();
var Bean1Token = exports.Bean1Token = Symbol();
var Bean2Token = exports.Bean2Token = Symbol();
var Bean3Token = exports.Bean3Token = Symbol();
var Bean1TestToken = exports.Bean1TestToken = Symbol();
var ConfigurationToken = exports.ConfigurationToken = Symbol();
var CustomConsolePrefixToken = exports.CustomConsolePrefixToken = Symbol();
//
// events.ts
//
var CustomApplicationEvent = /** @class */function (_super) {
    __extends(CustomApplicationEvent, _super);
    function CustomApplicationEvent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CustomApplicationEvent;
}(_2.ApplicationEvent);
exports.CustomApplicationEvent = CustomApplicationEvent;
//
// bean1.ts
//  singleton - every call to BeanFactory.getBean()
//              will provide the same bean per context
//

var Bean1 = /** @class */function () {
    function Bean1() {}
    Bean1.prototype.construct = function () {};
    Bean1.prototype.destruct = function () {};
    //
    // Api
    //
    Bean1.prototype.getSomething = function () {
        return 0;
    };
    __decorate([(0, _2.Autowired)(Bean2Token), __metadata("design:type", Bean2)], Bean1.prototype, "bean2", void 0);
    __decorate([_2.PostConstruct, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean1.prototype, "construct", null);
    __decorate([_2.PreDestroy, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean1.prototype, "destruct", null);
    Bean1 = __decorate([(0, _2.Bean)(Bean1Token)], Bean1);
    return Bean1;
}();
exports.Bean1 = Bean1;
//
// bean2.ts
//   prototype - every call to BeanFactory.getBean()
//               will provide new bean per context
//

var Bean2 = /** @class */function () {
    function Bean2() {
        var _this = this;
        this.disposer = function () {
            return console.log(_this.prefix + " some resource has disposed");
        };
    }
    Bean2.prototype.construct = function () {
        /* all dependencies ready */
        this.context.publishEvent(new CustomApplicationEvent());
        // All beans in current context and its parent contexts
        //   will able to handle this message using @EventListener.
        // See example below.
    };
    Bean2.prototype.destruct = function () {
        /* close other non disposable resources */
    };
    //
    // Api
    //
    Bean2.prototype.throwError = function () {
        throw new Error();
        // current context will broadcast
        //   ApplicationContextBeanRuntimeExceptionEvent
        // requires ApplicationContextAware to be implemented
        // Reccomendations:
        //   create UserNotifier service to show all error to user
        //     from @Throwable functions
    };
    Bean2.prototype.throwAsyncError = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error();
            });
        });
    };
    //
    // Event listeners
    //
    Bean2.prototype.handleApplicationContextStartEvent = function (e) {
        // Application context started!
        // All beans acquired in context start() function are instantiated
        //   with their dependencies"
    };
    Bean2.prototype.handleApplicationContextStopEvent = function (e) {
        // Application context stoped!
        // All beans destroyes and all disposables disposed
    };
    Bean2.prototype.handleApplicationContextBeanRuntimeExceptionEvent = function (e) {
        // Somewhere in this context or in child context bean throwed an error!
        // Show notification to user
        // const error: Error = e.exception; // raised error
        // const sourceContext = e.source; // context where error was raised
    };
    Bean2.prototype.handleCustomApplicationEvent = function (e) {
        // your custom event handler
    };
    __decorate([(0, _2.Autowired)(ApplicationContextToken), __metadata("design:type", Object)], Bean2.prototype, "context", void 0);
    __decorate([(0, _2.Autowired)(AbstractValueToken), __metadata("design:type", Number)], Bean2.prototype, "value", void 0);
    __decorate([(0, _2.Autowired)(CustomConsolePrefixToken), __metadata("design:type", String)], Bean2.prototype, "prefix", void 0);
    __decorate([_2.Disposable, __metadata("design:type", Function)], Bean2.prototype, "disposer", void 0);
    __decorate([_2.PostConstruct, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean2.prototype, "construct", null);
    __decorate([_2.PreDestroy, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean2.prototype, "destruct", null);
    __decorate([(0, _2.Throwable)(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean2.prototype, "throwError", null);
    __decorate([(0, _2.ThrowableAsync)(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", Promise)], Bean2.prototype, "throwAsyncError", null);
    __decorate([(0, _2.EventListener)(_2.ApplicationContextStartEvent), __metadata("design:type", Function), __metadata("design:paramtypes", [_2.ApplicationContextStartEvent]), __metadata("design:returntype", void 0)], Bean2.prototype, "handleApplicationContextStartEvent", null);
    __decorate([(0, _2.EventListener)(_2.ApplicationContextStopEvent), __metadata("design:type", Function), __metadata("design:paramtypes", [_2.ApplicationContextStopEvent]), __metadata("design:returntype", void 0)], Bean2.prototype, "handleApplicationContextStopEvent", null);
    __decorate([(0, _2.EventListener)(_2.ApplicationContextBeanRuntimeExceptionEvent), __metadata("design:type", Function), __metadata("design:paramtypes", [_2.ApplicationContextBeanRuntimeExceptionEvent]), __metadata("design:returntype", void 0)], Bean2.prototype, "handleApplicationContextBeanRuntimeExceptionEvent", null);
    __decorate([(0, _2.EventListener)(CustomApplicationEvent), __metadata("design:type", Function), __metadata("design:paramtypes", [CustomApplicationEvent]), __metadata("design:returntype", void 0)], Bean2.prototype, "handleCustomApplicationEvent", null);
    Bean2 = __decorate([(0, _2.Bean)(Bean2Token, { scope: "prototype" })], Bean2);
    return Bean2;
}();
exports.Bean2 = Bean2;
//
// applicationContext.ts
//

var ApplicationContext = /** @class */function (_super) {
    __extends(ApplicationContext, _super);
    function ApplicationContext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ApplicationContext.prototype.configure = function () {
        // map tokens before context bootstrapping
        _super.prototype.configure.call(this, new Map([[AbstractValueToken, ConcreteValueToken], [ConcreteValueToken, _2.FactoryBean.of(function () {
            return 0;
        })]]));
    };
    ApplicationContext.prototype.start = function () {
        // bootstrap context
        // instantiate bean1 with it's dependencies
        this.getBean(Bean1Token);
        _super.prototype.start.call(this);
    };
    return ApplicationContext;
}(_2.AbstractApplicationContext);
exports.ApplicationContext = ApplicationContext;
//
// applicationTestContext.ts
//

var ApplicationTestContext = /** @class */function (_super) {
    __extends(ApplicationTestContext, _super);
    function ApplicationTestContext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ApplicationTestContext.prototype.configure = function () {
        _super.prototype.configure.call(this, new Map([
        // map tokens before test context bootstrapping
        // replace original bean with test bean
        [Bean1Token, Bean1TestToken],
        // assign bean to token using factory wich calls every time
        //   when BeanFactory.getBean() called
        [ConcreteValueToken, _2.FactoryBean.of(function () {
            return 0;
        })], [CustomConsolePrefixToken, _2.FactoryBean.of(function () {
            return "[CONSOLE PREFIX]:";
        })],
        // assign real bean to abstract token
        [AbstractValueToken, ConcreteValueToken]]));
    };
    ApplicationTestContext.prototype.start = function () {
        // bootstrap context
        // instantiate value using FactoryBean
        this.getBean(CustomConsolePrefixToken); // `[CONSOLE PREFIX]:`
        // instantiate configuration (no @beans created)
        this.getBean(ConfigurationToken);
        // instantiate value using @bean from @Configuration
        //   cause of configuration method consolePrefix() replaced the token
        this.getBean(CustomConsolePrefixToken); // `[CUSTOM CONSOLE PREFIX]:`
        // instantiate bean with it's dependencies
        this.getBean(Bean1Token);
        _super.prototype.start.call(this);
    };
    return ApplicationTestContext;
}(_2.AbstractApplicationContext);
exports.ApplicationTestContext = ApplicationTestContext;
//
// Bean1Test.ts
//

var Bean1Test = /** @class */function (_super) {
    __extends(Bean1Test, _super);
    function Bean1Test() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Bean1Test.prototype.getSomething = function () {
        /* usual jest spy */
        return _super.prototype.getSomething.call(this);
    };
    Bean1Test.prototype.test1 = function () {
        expect(this.getSomething()).toBe(0);
        expect(this.getSomething).toBeCalled(); // check spy
    };
    Bean1Test.prototype.test2 = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    __decorate([_2.Spy, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean1Test.prototype, "getSomething", null);
    __decorate([_2.Test, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], Bean1Test.prototype, "test1", null);
    __decorate([_2.AsyncTest, __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", Promise)], Bean1Test.prototype, "test2", null);
    Bean1Test = __decorate([(0, _2.Bean)(Bean1TestToken)], Bean1Test);
    return Bean1Test;
}(Bean1);
exports.Bean1Test = Bean1Test;
//
// Bean3.ts
//   singleton bean for all contexts
//

var Bean3Test = /** @class */function (_super) {
    __extends(Bean3Test, _super);
    function Bean3Test() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Bean3Test = __decorate([(0, _2.Bean)(Bean3Token, { scope: "global" })], Bean3Test);
    return Bean3Test;
}(Bean1);
exports.Bean3Test = Bean3Test;
//
// Configuration.ts
//

var ApplicationConfiguration = /** @class */function () {
    function ApplicationConfiguration() {}
    ApplicationConfiguration.prototype.consolePrefix = function () {
        return "[CUSTOM CONSOLE PREFIX]:";
    };
    __decorate([(0, _2.bean)(CustomConsolePrefixToken), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], ApplicationConfiguration.prototype, "consolePrefix", null);
    ApplicationConfiguration = __decorate([(0, _2.Configuration)(ConfigurationToken)], ApplicationConfiguration);
    return ApplicationConfiguration;
}();
exports.ApplicationConfiguration = ApplicationConfiguration;
//
// ChildContext.ts
//
//   /*
//    * context inheritance
//    *   now BeanFactory.getBean() works as following:
//    *   1. search bean in current context, if found return it
//    *   2. search bean in parent context, if found return it,
//    *        if not in parent's parent and so on
//    *   3. if in parent tree bean not found instantiate it in child context
//    *        (if in child context abstract token is mapped to real)
//    *   4. if no suitable bean found and it is not required
//    *        (e.g. getBean() called with false as 2 argument)
//    *        then just return null, otherwise throw error
//    * usage:
//    */
//   const parentContext = new ApplicationContext();
//   parentContext.configure();
//   parentContext.start();
//   const childContext = new ChildContext()
//   childContext.configure();
//   childContext.setParent(parentContext); // !!!
//   childContext.start();
//

var ChildContext = /** @class */function (_super) {
    __extends(ChildContext, _super);
    function ChildContext() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ChildContext;
}(_2.AbstractApplicationContext);
exports.ChildContext = ChildContext;
//
// !!! main.ts
//   instantiate your application here
//
// const applicationContext = new ApplicationContext();
// ApplicationContextProvider.get().setApplicationContext(applicationContext);
//
// !!! Not beans files.ts
//   maybe you want to use IoC somewhere else
//
// const isRequired: boolean = false;
// const extraMapOnlyForSpecificCall = new Map<any, TWishedBeanOrFactory>([
//   /* remap existings tokens only for specific call */
//   [AbstractValueToken, FactoryBean.of(() => 1)]
// ])
// const bean1 = ApplicationContextProvider.get().getApplicationContext()
//   .getBean(Bean1Token, isRequired, extraMapOnlyForOneCall)
//
// !!! React files.ts
//
// const applicationContext = ApplicationContextProvider.get()
//   .getApplicationContext();
//
// class ReactComponent extends React.Component {
//
//   constructor() {
//      const bean1 = applicationContext.getBean(Bean1Token);
//   }
//
//   @Throwable(applicationContext)
//   handleClick() {
//     throw new Error("method not implemented");
//     // applicationContext will broadcast
//     //   ApplicationContextBeanRuntimeExceptionEvent
//   }
//
//   render() {
//     return (<Button onClick={this.handleClick} />);
//   }
//
// }
//
//# sourceMappingURL=packageDemo.js.map