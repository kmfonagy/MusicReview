"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AbstractBeanFactory = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _java = require("../java");

var _javax = require("../javax");

var _rxjava = require("../rxjava");

var _annotations = require("../org.springframework.context/annotations");

var _annotations2 = require("./annotations");

var _factoryBean = require("./factoryBean");

var __assign = undefined && undefined.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = undefined && undefined.__values || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
        next: function next() {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = undefined && undefined.__read || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
        }
    } catch (error) {
        e = { error: error };
    } finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = undefined && undefined.__spread || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) {
        ar = ar.concat(__read(arguments[i]));
    }return ar;
};

//
// Types
//
var emptyMap = new Map();
//
// BeanFactory is a Ioc container
//
var PFX = "[ABSTRACT BEAN FACTORY]:";
var AbstractBeanFactory = /** @class */function () {
    /* constructor */
    function AbstractBeanFactory() {
        this.running = false;
        this.beansMap = new Map();
        this.beanPathMap = new Map();
    }
    // retrieve instantiated bean from cache
    AbstractBeanFactory.prototype.findSingletonInstance = function (key) {
        if (this.beansMap.has(key)) {
            return this.beansMap.get(key);
        }
        if (this.parentBeanFactory) {
            return this.parentBeanFactory.findSingletonInstance(key);
        }
        return null;
    };
    // retrieve instantiated bean from cache
    AbstractBeanFactory.prototype.findGlobalInstance = function (key) {
        if (AbstractBeanFactory.beansMap.has(key)) {
            return AbstractBeanFactory.beansMap.get(key);
        }
        return null;
    };
    AbstractBeanFactory.prototype.set = function (key, value) {
        this.beanPathMap.set(key, value);
    };
    AbstractBeanFactory.prototype.unset = function (key) {
        this.beanPathMap.delete(key);
    };
    // set bean map
    AbstractBeanFactory.prototype.configure = function (beanPathMap) {
        var e_1, _a;
        try {
            for (var _b = __values(beanPathMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                this.beanPathMap.set(key, beanPathMap.get(key));
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    // proxy wished beans to specified context
    AbstractBeanFactory.prototype.inherit = function (context, wishedBeans) {
        var e_2, _a;
        var _loop_1 = function _loop_1(whishedBean) {
            this_1.beanPathMap.set(whishedBean, _factoryBean.FactoryBean.of(function () {
                return context.getBean(whishedBean);
            }));
        };
        var this_1 = this;
        try {
            for (var wishedBeans_1 = __values(wishedBeans), wishedBeans_1_1 = wishedBeans_1.next(); !wishedBeans_1_1.done; wishedBeans_1_1 = wishedBeans_1.next()) {
                var whishedBean = wishedBeans_1_1.value;
                _loop_1(whishedBean);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (wishedBeans_1_1 && !wishedBeans_1_1.done && (_a = wishedBeans_1.return)) _a.call(wishedBeans_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    // proxy all not found beans to specified context
    AbstractBeanFactory.prototype.setParent = function (context) {
        this.parentBeanFactory = context;
    };
    // execute all disposers in bean
    AbstractBeanFactory.prototype.disposeBean = function (instance) {
        var e_3, _a;
        var key;
        var value;
        try {
            for (var _b = __values(this.beansMap.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                if (entry[1] === instance) {
                    key = entry[0];
                    value = entry[1];
                    break;
                }
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        if (!key) {
            throw new _java.Exception(PFX + " no such bean instance");
        }
        var bean = value;
        if (Reflect.hasMetadata(_rxjava.disposableToken, bean.constructor)) {
            var disposerKeys = Reflect.getMetadata(_rxjava.disposableToken, bean.constructor);
            disposerKeys.forEach(function (disposerKey) {
                if (bean[disposerKey] && bean[disposerKey] instanceof Function) {
                    bean[disposerKey].call(bean);
                    bean[disposerKey] = null;
                }
            });
        }
    };
    // destroy specified bean
    AbstractBeanFactory.prototype.destroyBean = function (instance) {
        var e_4, _a;
        var key;
        var value;
        try {
            for (var _b = __values(this.beansMap.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var entry = _c.value;
                if (entry[1] === instance) {
                    key = entry[0];
                    value = entry[1];
                    break;
                }
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        if (!key) {
            throw new _java.Exception(PFX + " no such bean instance");
        }
        var bean = value;
        this.disposeBean(bean);
        if (Reflect.hasMetadata(_javax.preDestroyHooksToken, bean.constructor)) {
            var preDestroyHook = Reflect.getMetadata(_javax.preDestroyHooksToken, bean.constructor);
            bean[preDestroyHook].call(bean);
        }
        this.beansMap.delete(key);
    };
    // instantiate bean or retrieve it from cache
    AbstractBeanFactory.prototype.getBean = function (wishedBean, required, extraBeanPathMap) {
        if (required === void 0) {
            required = true;
        }
        if (extraBeanPathMap === void 0) {
            extraBeanPathMap = null;
        }
        extraBeanPathMap = extraBeanPathMap || emptyMap;
        if (wishedBean == null) {
            throw new _java.Exception(PFX + " wished bean should not be null");
        }
        // 1. resolve string path
        if (typeof wishedBean === "string") {
            // 1.1. resolve string path to either another string path or symbol token
            var nextWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
            // 1.2. try again until get symbol token
            return this.getBean(nextWishedBean, required, extraBeanPathMap);
        }
        // 2. get bean by symbol token
        if ((typeof wishedBean === "undefined" ? "undefined" : _typeof(wishedBean)) === "symbol") {
            // 2.1 search in instances
            if (this.beansMap.has(wishedBean)) {
                return this.beansMap.get(wishedBean);
            }
            // 2.2. resolve symbol token to another token
            if (!this.beanPathMap.has(wishedBean) && !extraBeanPathMap.has(wishedBean)) {
                if (this.parentBeanFactory) {
                    // 2.2.1. resolve in parents
                    var newWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
                    if (!newWishedBean) {
                        // 2.2.1.1. instantiate by token because parents not awared about this token
                        return this.getBeanByToken(wishedBean, required, extraBeanPathMap);
                    } else {
                        // 2.2.1.2. try get again with new path that was resolved in parents
                        return this.getBean(newWishedBean, required, extraBeanPathMap);
                    }
                } else {
                    // 2.2.2. instantiate by token because there is no parents
                    return this.getBeanByToken(wishedBean, required, extraBeanPathMap);
                }
            }
            // 2.3. resolve in itself
            var nextWishedBean = this.resolveBean(wishedBean, extraBeanPathMap);
            // 2.4. try get again with new path that was resolved by itself
            return this.getBean(nextWishedBean, required, extraBeanPathMap);
        }
        // 3. get bean by factory
        if (wishedBean instanceof _factoryBean.FactoryBean) {
            var beanFactory = wishedBean;
            return beanFactory.factory();
        }
        // 4. bean is resolved from instances
        return wishedBean;
    };
    AbstractBeanFactory.prototype.resolveBean = function (wishedBean, extraBeanPathMap) {
        if (extraBeanPathMap === void 0) {
            extraBeanPathMap = null;
        }
        extraBeanPathMap = extraBeanPathMap || emptyMap;
        // 1. search in instances
        if (this.beansMap.has(wishedBean)) {
            return this.beansMap.get(wishedBean);
        }
        // 2. search bean path mapping in itself
        if (!this.beanPathMap.has(wishedBean) && !extraBeanPathMap.has(wishedBean)) {
            // 2.1. search bean path mapping in parents
            if (this.parentBeanFactory) {
                return this.parentBeanFactory.resolveBean(wishedBean, extraBeanPathMap);
            }
            // 2.2. not resolved
            return null;
        }
        // 3. retrieve path mapping from itself
        if (this.beanPathMap.has(wishedBean)) {
            return this.beanPathMap.get(wishedBean);
        } else {
            return extraBeanPathMap.get(wishedBean);
        }
    };
    AbstractBeanFactory.prototype.getBeanByToken = function (token, required, extraBeanPathMap) {
        var _this = this;
        // 1. check beans definitions exists in package
        if (!Reflect.hasMetadata(_annotations.beansToken, AbstractBeanFactory)) {
            throw new _java.Exception(PFX + " no beans found in context");
        }
        // 2. find bean definition by type
        var beanDefinitions = Reflect.getMetadata(_annotations.beansToken, AbstractBeanFactory);
        var beanDefinition = beanDefinitions.find(function (beanDefinition) {
            return beanDefinition.token === token;
        });
        if (!beanDefinition) {
            if (required) {
                console.log(PFX + " bean with such token not provided in context", token);
                throw new _java.Exception(PFX + " bean with such token not provided in context");
            }
            return null;
        }
        if (beanDefinition.factory == null && beanDefinition.bean == null) {
            throw new _java.Exception(PFX + " incorrect bean definition");
        }
        // 3. get instance
        var bean;
        if (beanDefinition.scope === "singleton") {
            bean = this.findSingletonInstance(beanDefinition.token);
            if (!bean) {
                // instantiate
                bean = this.instantiateBean(beanDefinition);
                this.beansMap.set(beanDefinition.token, bean);
                this.autowire(bean, beanDefinition, extraBeanPathMap);
                this.resource(bean, beanDefinition);
            }
        } else if (beanDefinition.scope === "global") {
            bean = this.findGlobalInstance(beanDefinition.token);
            if (!bean) {
                // instantiate
                bean = this.instantiateBean(beanDefinition);
                AbstractBeanFactory.beansMap.set(beanDefinition.token, bean);
                this.autowire(bean, beanDefinition, extraBeanPathMap);
                this.resource(bean, beanDefinition);
            }
        } else if (beanDefinition.scope === "prototype") {
            // instantiate
            bean = this.instantiateBean(beanDefinition);
            this.beansMap.set(Symbol(), bean);
            this.autowire(bean, beanDefinition, extraBeanPathMap);
            this.resource(bean, beanDefinition);
        } else {
            throw new _java.Exception(PFX + " usupported scope - " + beanDefinition.scope);
        }
        if (beanDefinition.factory != null) {
            // 4. for configuration bean register all declared @beans
            if (Reflect.hasMetadata(_annotations.beansToken, bean.constructor)) {
                var beansDefinitions = Reflect.getMetadata(_annotations.beansToken, bean.constructor);
                beansDefinitions.forEach(function (beanDefinition) {
                    // register additional bean
                    var beanDefinitions = Reflect.getMetadata(_annotations.beansToken, AbstractBeanFactory) || [];
                    Reflect.defineMetadata(_annotations.beansToken, __spread([__assign({}, beanDefinition, { bean: bean })], beanDefinitions), AbstractBeanFactory);
                    _this.unset(beanDefinition.token);
                });
            }
            // 5. call post construct hook
            if (Reflect.hasMetadata(_javax.postConstructHooksToken, bean.constructor)) {
                var postConstructHook = Reflect.getMetadata(_javax.postConstructHooksToken, bean.constructor);
                bean[postConstructHook].call(bean);
            }
        }
        return bean;
    };
    AbstractBeanFactory.prototype.instantiateBean = function (beanDefinition) {
        if (beanDefinition.factory != null) {
            var type = beanDefinition.factory.prototype;
            return new type.constructor(this);
        }
        if (!beanDefinition.bean) {
            throw new _java.Exception(PFX + " bean should not be null");
        }
        return beanDefinition.bean[beanDefinition.factoryProperty].call(beanDefinition.bean);
    };
    AbstractBeanFactory.prototype.autowire = function (bean, beanDefinition, extraBeanPathMap) {
        var e_5, _a;
        if (!beanDefinition.factory) {
            return;
        }
        if (Reflect.hasMetadata(_annotations2.dependenciesToken, bean.constructor)) {
            var dependencies = Reflect.getMetadata(_annotations2.dependenciesToken, bean.constructor);
            var _loop_2 = function _loop_2(dependency) {
                // check property is empty
                var propertyName = dependency.property;
                var propertyValue = bean[propertyName];
                if (!propertyValue) {
                    if (dependency.wishedBean == null) {
                        throw new _java.Exception(PFX + " incorrect dependency definition for " + dependency.property);
                    }
                    if (dependency.resolve) {
                        var resolverPath = beanDefinition.resolver;
                        var resolverBean = this_2.getBean(resolverPath, true, extraBeanPathMap);
                        var resolvedArray = resolverBean.resolve(dependency.resolve, bean);
                        if (resolvedArray) {
                            var resolverMap_1 = new Map(resolvedArray);
                            extraBeanPathMap.forEach(function (v, k) {
                                return resolverMap_1.set(k, v);
                            });
                            extraBeanPathMap = resolverMap_1;
                        }
                    }
                    bean[propertyName] = this_2.getBean(dependency.wishedBean, dependency.required, extraBeanPathMap);
                } else {
                    throw new _java.Exception(PFX + " autowired property should be null " + dependency.property);
                }
            };
            var this_2 = this;
            try {
                for (var dependencies_1 = __values(dependencies), dependencies_1_1 = dependencies_1.next(); !dependencies_1_1.done; dependencies_1_1 = dependencies_1.next()) {
                    var dependency = dependencies_1_1.value;
                    _loop_2(dependency);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (dependencies_1_1 && !dependencies_1_1.done && (_a = dependencies_1.return)) _a.call(dependencies_1);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
        }
    };
    AbstractBeanFactory.prototype.resource = function (bean, beanDefinition) {
        var e_6, _a;
        if (!beanDefinition.factory) {
            return;
        }
        if (Reflect.hasMetadata(_javax.resourceDependenciesToken, bean.constructor)) {
            var resources = Reflect.getMetadata(_javax.resourceDependenciesToken, bean.constructor);
            try {
                for (var resources_1 = __values(resources), resources_1_1 = resources_1.next(); !resources_1_1.done; resources_1_1 = resources_1.next()) {
                    var resource = resources_1_1.value;
                    // check property is empty
                    var propertyName = resource.property;
                    var propertyValue = bean[propertyName];
                    if (!propertyValue) {
                        bean[propertyName] = this.getResource(resource.url);
                    } else {
                        throw new _java.Exception(PFX + " resource property should be null " + resource.property);
                    }
                }
            } catch (e_6_1) {
                e_6 = { error: e_6_1 };
            } finally {
                try {
                    if (resources_1_1 && !resources_1_1.done && (_a = resources_1.return)) _a.call(resources_1);
                } finally {
                    if (e_6) throw e_6.error;
                }
            }
        }
    };
    //
    // ICloseable implementation
    //
    AbstractBeanFactory.prototype.close = function () {
        if (this.isRunning()) {
            this.stop();
        }
        this.beanPathMap = null;
        this.beansMap = null;
    };
    //
    // ILifecycle implementation
    //
    AbstractBeanFactory.prototype.start = function () {
        if (!this.isRunning()) {
            if (this.beanPathMap && this.beansMap) {
                this.running = true;
            } else {
                throw new _java.Exception(PFX + " bean factory has not configured");
            }
        } else {
            throw new _java.Exception(PFX + " bean factory already started");
        }
    };
    AbstractBeanFactory.prototype.stop = function () {
        var e_7, _a, e_8, _b;
        if (this.isRunning()) {
            var disposeBeansKeys = this.beansMap.keys();
            try {
                for (var disposeBeansKeys_1 = __values(disposeBeansKeys), disposeBeansKeys_1_1 = disposeBeansKeys_1.next(); !disposeBeansKeys_1_1.done; disposeBeansKeys_1_1 = disposeBeansKeys_1.next()) {
                    var key = disposeBeansKeys_1_1.value;
                    var bean = this.beansMap.get(key);
                    this.disposeBean(bean);
                }
            } catch (e_7_1) {
                e_7 = { error: e_7_1 };
            } finally {
                try {
                    if (disposeBeansKeys_1_1 && !disposeBeansKeys_1_1.done && (_a = disposeBeansKeys_1.return)) _a.call(disposeBeansKeys_1);
                } finally {
                    if (e_7) throw e_7.error;
                }
            }
            var destroyBeansKeys = this.beansMap.keys();
            try {
                for (var destroyBeansKeys_1 = __values(destroyBeansKeys), destroyBeansKeys_1_1 = destroyBeansKeys_1.next(); !destroyBeansKeys_1_1.done; destroyBeansKeys_1_1 = destroyBeansKeys_1.next()) {
                    var key = destroyBeansKeys_1_1.value;
                    var bean = this.beansMap.get(key);
                    this.destroyBean(bean);
                }
            } catch (e_8_1) {
                e_8 = { error: e_8_1 };
            } finally {
                try {
                    if (destroyBeansKeys_1_1 && !destroyBeansKeys_1_1.done && (_b = destroyBeansKeys_1.return)) _b.call(destroyBeansKeys_1);
                } finally {
                    if (e_8) throw e_8.error;
                }
            }
            this.running = false;
        } else {
            throw new _java.Exception(PFX + " bean factory has not started");
        }
    };
    AbstractBeanFactory.prototype.isRunning = function () {
        return this.running;
    };
    AbstractBeanFactory.prototype.getResource = function (url) {
        return AbstractBeanFactory.resources[url];
    };
    AbstractBeanFactory.resources = {};
    AbstractBeanFactory.beansMap = new Map();
    return AbstractBeanFactory;
}();
exports.AbstractBeanFactory = AbstractBeanFactory;
//# sourceMappingURL=abstractBeanFactory.js.map